# 并发编程记录

## 一 并发编程基础

​	1.无状态类是线程安全的  因为他们没有具体状态   线程数据不共享 每个对象都是单独的实例  所以是线程安全的。

​	2.线程中 保持原子性不太可能++i   i++操作都不会是原子性操作，因为其中操作分为读取——修改——写入。凡是存在竞态条件都不具备线程安全可行性

​	3. BlockingQueue扩展了Queue，增加了可阻塞队列的插入和获取等操作。如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用元素。如果队列已满那么将一直阻塞，直到有多余空间。

​	4.ConcurrentHashMap也是一个基于散列的Map,但它使用了一种完全不同的加锁机制。它采用的是一种分段锁。并发下ConcurrrentHashMap size()，isEmpty()只是估计预算可能并不是当前map的真正值.

5.CopyOnWriteArrayList用来替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要枷锁或复制，在进行修改操作时，对List复制个副本进行操作。

6.Deque和BlockingDeque 分别对Queue和BlockingQueue进行了扩展。

  Deque

   是一个双向队列，实现了在队列头和队列尾高效插入和移除，具体实现ArrayDeque和LinkedBlockingDeque。

7.闭锁    相当于一扇门  闭锁状态结束前  所有线程都需要等待 CountDownLatch  await()等待线程结束

countDown()减去一个计数

8.FutureTask  获取未来结果  可以在多个线程中的结果  获取到一个线程中，Executor框架中表示异步任务，此外还可以用来表示一些时间较长的计算。Future.get()来获取线程结果   在获取结果前一直阻塞。

9.信号量  用来控制访问某个特定资源的操作数量，或者同时执行某个指定操作的数量，或者对容器加边界Semaphore  

​	.acquire()获取许可。

​	.release()释放许可。

10.侧栏  侧栏类似于闭锁，它能阻塞一组线程直到某个事件发生。侧栏和闭锁的关键在于，所有线程必须同时到达侧栏位置，才能继续执行，简单来说就是等待其他线程一起到达侧栏位置  才能继续执行下一步操作。类似于公司团建  必须等待某个领导线程到齐了 才能开始下一步操作。

CyclicBarrier可以使一定数量的参与方反复地在侧栏位置汇集。当有线程到达时会调用await方法 直到所有线程到达侧栏。

 11.线程池策略

​	newFixedThreadPool. 将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生未知Exception而结束，那么线程池会补充一个新线程）

​	newCachedThreadPool。将创建一个缓存池，如果线程池的当前规模超过了处理需求时，那么将回收空闲线程，而当需求增加是，则可以添加新线程，线程池的规模不存在任何限制。

​	newSingleThreadExecutor。是一个单独的线程Executor，它将创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能确保任务在队列顺序来串行执行

​	newScheduledThread。创建固定长度线程池，而且以延迟或定时的方式来执行任务，类似Timer

​	newFixedThreadPool和newCachedThreadPool两个工厂方法返回通用ThreadPool-Executor实例

12.Executor

​	

## 二.**携带任务结果的Callable与Future**
 **Runnable**有一定局限性，它本身是无法返回一个返回值或者抛出异常.
 
 **Executor**执行任务的四个阶段:创建，提交，开始，完成.—但是有的任务时间过长,希望提前结束任务。
 
 在**Executor**中已提交的任务可以提前取消，但对于那些已经开始执行的任务，只有它们能响应中断，才能取消。取消一个已经完成的任务是不被影响的。
 
 **Future**表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消.Future的生命周期只能前进，不能后退。
 就像ExecutorService的生命周期一样。当某个任务完成后它就永远留在“完成”状态下。
 
       1.get方法的行为取决于任务的状态（尚未开始，正在运行，已经完成），如果已经完成那么get会立即返回或者抛出一个Exception，
       如果没有完成，那么get将会一直阻塞到完成。
       
            1.1如果任务抛出异常，那么get将该异常封装为ExecutionException并重新抛出。 
            
            1.2如果任务被取消,则抛出CancellationException。
            
            1.3如果get抛出ExecutionException那么可以通过getCause来获得被封装的初始异常。
            
  ps:从某些方面异步现场操作可能达不到想要的效果,例如:一个HTML渲染,一个负责文字,一个负责图片,文字渲染早已完成,
  但是图片渲染一直未完成 这种方式的效率和串行执行没什么差别。        

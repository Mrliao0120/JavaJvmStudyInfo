一.**携带任务结果的Callable与Future**
 **Runnable**有一定局限性，它本身是无法返回一个返回值或者抛出异常.
 **Executor**执行任务的四个阶段:创建，提交，开始，完成.—但是有的任务时间过长,希望提前结束任务。
 在**Executor**中已提交的任务可以提前取消，但对于那些已经开始执行的任务，只有它们能响应中断，才能取消。取消一个已经完成的任务是不被影响的。
 **Future**表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消.Future的生命周期只能前进，不能后退。
 就像ExecutorService的生命周期一样。当某个任务完成后它就永远留在“完成”状态下。
       1.get方法的行为取决于任务的状态（尚未开始，正在运行，已经完成），如果已经完成那么get会立即返回或者抛出一个Exception，
       如果没有完成，那么get将会一直阻塞到完成。
            1.1如果任务抛出异常，那么get将该异常封装为ExecutionException并重新抛出。 
            1.2如果任务被取消,则抛出CancellationException。
            1.3如果get抛出ExecutionException那么可以通过getCause来获得被封装的初始异常。
  ps:从某些方面异步现场操作可能达不到想要的效果,例如:一个HTML渲染,一个负责文字,一个负责图片,文字渲染早已完成,
  但是图片渲染一直未完成 这种方式的效率和串行执行没什么差别。        
